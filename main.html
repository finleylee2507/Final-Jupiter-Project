<html>
<!DOCTYPE html>
<meta charset="utf-8">

<style>
div.tooltip {
  position: absolute;
  text-align: center;
  width: 200px;
  height: 50px;
  padding: 2px;
  font: 12px sans-serif;
  background: lightsteelblue;
  border: 0px;
  border-radius: 8px;
  pointer-events: none;
}

h1 {
    text-align: center;
    font: sans-serif;
}
</style>

<script src="https://d3js.org/d3.v7.min.js"></script>


<body>
    <div><h1>Country vs Removal Requests</h1> </div>
    <script>
        // Line Bubble Plot

        //Plot vars
        let width =  document.documentElement.clientWidth -100 , height =  document.body.clientHeight;
        let margin = { top: 50, right: 100, bottom: 50, left: 100 };
        let svg_bubble = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)

        let tooltip = d3.select("body")
            .append("div")
            .style("opacity", 0)
            .attr("class", "tooltip")
            .style("background-color", "white")
            .style("border", "solid")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("padding", "5px")
        let bubble_width = width - margin.left - margin.right;
        let bubble_height = height - margin.top - margin.bottom;

        //Variables using the products data
        let products_data; 
        let country_counts;

        //Variables using the percent data
        let percents_data;
        let percents_items_normalized, percents_items, percents_removed_percent;

        //Misc Variables
        let continents_country = new d3.InternMap([]);
        let country_continent = new d3.InternMap([]);

        

        function aggregate_countries() {
            country_counts = d3.rollup(products_data, v => d3.sum(v, d => +d.total), d => d.country)

            //go through every row and multiply the number of items requested to be removed by the percent of the 2 removed categories
            //can be changed
            percents_items_normalized = d3.rollup(percents_data, v => d3.sum(v, d => (+d.items)*((+d.removed_legal+(+d.removed_policy))/100.0)), d => d.country)
            percents_items = d3.rollup(percents_data, v => d3.sum(v, d => +d.items), d => d.country)
            percents_removed_percent = new d3.InternMap()
            Array.from(percents_items.keys()).forEach(e => {
                percents_removed_percent.set(e, percents_items_normalized.get(e)/percents_items.get(e))
            });

            //remove countries from country counts that arent in the percentages table
            Array.from(country_counts.keys()).forEach(e => {
                if(!percents_removed_percent.has(e)) {
                    country_counts.delete(e);
                }
            });

            //country_continents = d3.group(percents_data, d => d.continent, d=> d.country)
            percents_data.forEach(e => {
                var continent = e.continent;
                var country = e.country;
                if(!continents_country.has(continent)) {
                    continents_country.set([country])
                } else {
                    continents_country.set(continents_country.get(continent).append(country))
                }
                if(!country_continent.has(country)) {
                    country_continent.set(continent)
                }
            });
        }

        function check_intersection(c1, r1, c2, r2) {
            d = Math.sqrt((c1[0] - c2[0]) * (c1[0] - c2[0]) + (c1[1] - c2[1]) * (c1[1] - c2[1]))
            //console.log([c1, r1, c2, r2, d])
            if((d <= r1 - r2) || (d <= r2 - r1) || (d < r1 + r2) || (d == r1 + r2))
                return true
            return false
        }

        function check_breaks_plane(c1, r1, c2, r2) {
            var left = c1[0] - r1;
            var right = c1[0] + r1;
            if(((c2[0]+r2 > left) && c2[0] <= c1[0]) || ((c2[0]-r2 < right) && c2[0] >= c1[0])){
                return true
            }
            return false
        }

        function get_possible(c1, r1, c2, r2) {
            var min=margin.top, max=bubble_height, step=0.01, diff=0.01;
            var works = []
            var current = min;
            do {
                if(!check_intersection([c1[0], current], r1, c2, r2)){
                    works.push(current)
                    /* if(current < c2[1] && current > works[0]) {
                        works[0] = current
                    } else if (current > c2[1] && current < works[1]){
                        works[1] = current
                    } */
                }
                current += step;
            } while(current<= max)
            //console.log(works)
            //console.log(c2)
            var left = works.filter(function (d) { return d < c2[1]})
            if(left.length == 0){
                left = 0
            } else {
                left = d3.max(left)
            }
            
            var right = works.filter(function (d) { return d > c2[1]})
            if(right.length == 0){
                left = height
            } else {
                right = d3.min(right)
            }
            
            return [left, right]
        }

        function merge_ranges(intervals, r) {
            var result = [];
            var previous = intervals[0];
            
            for (let i = 1; i < intervals.length; i += 1) {
                if (previous[1] >= intervals[i][0]) {
                    previous = [previous[0], Math.max(previous[1], intervals[i][1])];
                } else {
                    result.push(previous);
                    previous = intervals[i];
                }
            }
            result.push(previous);
            
            intervals = result
            console.log(intervals)
            var previous = intervals[0];
            
            var best = previous[0];
            for (let i = 1; i < intervals.length; i += 1) {
                if (intervals[i][0] - previous[1] >= r*2) {
                    if(Math.abs(((bubble_height + margin.top)/2.0)-previous[1]) < Math.abs(((bubble_height + margin.top)/2.0)-best)){
                        best = previous[1]
                    }
                    if(Math.abs(((bubble_height + margin.top)/2.0)-intervals[i][0]) < Math.abs(((bubble_height + margin.top)/2.0)-best)){
                        best = intervals[i][0]
                    }
                }
                previous = intervals[i]
            }
            if(Math.abs(((bubble_height + margin.top)/2.0)-previous[1]) < Math.abs(((bubble_height + margin.top)/2.0)-best)){
                best = previous[1]
            }

            return best;
        }

        function open_y(placed_circles, result_y, this_point, xScale, sizeScale) {
            if(placed_circles.length == 0) {
                return new Promise(resolve =>setTimeout(() => resolve(result_y), 1));
            }

            temp_placed_circles = []
            this_center = [xScale(percents_removed_percent.get(this_point[0])), result_y]
            this_radius = sizeScale(this_point[1])
            placed_circles.forEach(function(d) {
                other_center = [xScale(percents_removed_percent.get(d[0])), d[2]]
                other_radius = sizeScale(d[1])
                if(check_breaks_plane(this_center, this_radius, other_center, other_radius)){
                    temp_placed_circles.push(d)
                }
            })
            if(temp_placed_circles.length == 0)
            {
                return new Promise(resolve =>setTimeout(() => resolve(result_y), 1));
            }
            var valid_heights = []
            temp_placed_circles.forEach(function(d) {
                other_center = [xScale(percents_removed_percent.get(d[0])), d[2]]
                other_radius = sizeScale(d[1])
                valid_heights.push(get_possible(this_center, this_radius, other_center, other_radius))
            })
            
            best_place = merge_ranges(valid_heights.sort((a, b) => d3.ascending(a[0], b[0])), this_radius)
            return new Promise(resolve =>setTimeout(() => resolve(best_place), 1));
        }

        async function drawBubble() {

            const xScale = d3.scaleLinear().domain([0, 1]).range([margin.left, bubble_width+margin.left])
            const sizeScale = d3.scaleLog().domain([d3.least(country_counts, ([, v]) => v)[1], d3.greatest(country_counts, ([, v]) => v)[1]]).range([5,50])
            const countryColorScale = d3.scaleOrdinal().domain(continents_country.keys()).range(d3.schemeTableau10)

            var countries_sorted =  Array.from(country_counts).sort((a, b) => d3.descending(a[1], b[1]))//.filter(function (d) { return d[1] > 500})

            countries_sorted.forEach(function (d, i){
                countries_sorted[i] = countries_sorted[i].concat((bubble_height + margin.top)/2.0)
            })
            var temp_countries_sorted;
            for(i in countries_sorted) {
                countries_sorted[i][2] = await open_y(countries_sorted.filter(function (e,j) {return j<i}), countries_sorted[i][2], countries_sorted[i], xScale, sizeScale)
                temp_countries_sorted = countries_sorted.filter(function (e,j) {return j<=i});

                svg_bubble.selectAll("circle")
                .data(temp_countries_sorted)
                .join(
                enter => enter.append("circle")
                .attr("country", d=>d[0])
                .attr("cx", d => xScale(percents_removed_percent.get(d[0])))
                .attr("cy", d => d[2])
                .transition().duration(1000)
                .attr("r", d => sizeScale(d[1]))
                .attr("fill", d => countryColorScale(d[0]))
                )
                .on("mouseover", function(event, d) {
                    tooltip
                    .style("opacity", 1)
                })
                .on("mousemove", function(event, d) {
                    tooltip
                    .html('<u>' + d[0] + '</u>' + "<br>Removal Requests: " + d[1] + "<br>%Removed: " + percents_removed_percent.get(d[0]))
                    .style("left", (event.pageX+20) + "px")
                    .style("top", (event.pageY-30) + "px")
                })
                .on("mouseleave", function(event, d) {
                    tooltip
                    .style("opacity", 0)
                })
            }

            /*
            svg_bubble.selectAll("circle")
                .data(countries_sorted)
                .join(
                enter => enter.append("circle")
                .attr("country", d=>d[0])
                .attr("cx", d => xScale(percents_removed_percent.get(d[0])))
                .attr("cy", d => d[2])
                .transition().duration(1000)
                .attr("r", d => sizeScale(d[1]))
                .attr("fill", d => countryColorScale(d[0]))
                .on("mouseover", function(event, d) {
                    tooltip
                    .style("opacity", 1)
                })
                .on("mousemove", function(event, d) {
                    tooltip
                    .html('<u>' + d[0] + '</u>' + "<br>Removal Requests: " + d[1] + "<br>%Removed: " + percents_removed_percent.get(d[0]))
                    .style("left", (event.pageX+20) + "px")
                    .style("top", (event.pageY-30) + "px")
                })
                .on("mouseleave", function(event, d) {
                    tooltip
                    .style("opacity", 0)
                }))
            */
        }

        async function ready() {
            products_data = await d3.csv("removal-requests-products.csv");
            percents_data = await d3.csv("removal-requests-percents.csv");

            //aggregate_countries()

            country_counts = d3.rollup(products_data, v => d3.sum(v, d => +d.total), d => d.country)

            //go through every row and multiply the number of items requested to be removed by the percent of the 2 removed categories
            //can be changed
            percents_items_normalized = d3.rollup(percents_data, v => d3.sum(v, d => (+d.items)*((+d.removed_legal+(+d.removed_policy))/100.0)), d => d.country)
            percents_items = d3.rollup(percents_data, v => d3.sum(v, d => +d.items), d => d.country)
            percents_removed_percent = new d3.InternMap()
            Array.from(percents_items.keys()).forEach(e => {
                percents_removed_percent.set(e, percents_items_normalized.get(e)/percents_items.get(e))
            });

            //remove countries from country counts that arent in the percentages table
            Array.from(country_counts.keys()).forEach(e => {
                if(!percents_removed_percent.has(e)) {
                    country_counts.delete(e);
                }
            });

            //country_continents = d3.group(percents_data, d => d.continent, d=> d.country)
            percents_data.forEach(e => {
                var continent = e.continent;
                var country = e.country;
                if(!continents_country.has(continent)) {
                    continents_country.set([country])
                } else {
                    continents_country.set(continents_country.get(continent).append(country))
                }
                if(!country_continent.has(country)) {
                    country_continent.set(continent)
                }
            });

            drawBubble()
        }
        

        ready();
    </script>

</body>


