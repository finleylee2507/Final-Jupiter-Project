<html>
<!DOCTYPE html>
<meta charset="utf-8">

<style>

    body {
        font-family: 'Poppins', sans-serif;
    }

    div {
        visibility: hidden;
    }

    div.tooltip {
        position: absolute;
        text-align: center;
        width: 200px;
        height: 50px;
        padding: 2px;
        font-size: 12px;
        background: lightsteelblue;
        border-radius: 8px;
        pointer-events: none;
        display: none;
    }

    div.loading {
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: 1000;
        top: 0px;
        left: 0px;
    }

    h1 {
        text-align: center;
    }

    .tool-tip-flag-icon {
        position: relative;
        top: 2px;
    }

</style>

<script src="https://d3js.org/d3.v7.min.js"></script>
<link href="https://fonts.googleapis.com" rel="preconnect">
<link crossorigin href="https://fonts.gstatic.com" rel="preconnect">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@100;200;300;400;500;600;700;800;900&display=swap"
      rel="stylesheet">

<body>
<div class="loading"></div>
<div><h1>Country vs Removal Requests</h1></div>
<div class="dropdown-wrapper">
    Continent Displayed: <select class="dropdown" id="continent-selection"></select>
</div>
<script>

    // Line Bubble Plot

    //Plot vars
    let width = document.documentElement.clientWidth, height = 950
    let margin = {top: 50, right: 500, bottom: 50, left: 100}
    let quadrants = [0.25, 0.50, 0.75]

    let svg_bubble = d3.select("body").append("svg")
        .attr("class", "svg_bubble")
        .attr("width", width)
        .attr("height", height)

    let defs = svg_bubble.append("defs")

    let tooltip = d3.select("body")
        .append("div")
        .style("opacity", 0)
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "2px")
        .style("border-radius", "5px")
        .style("padding", "5px")
    let bubble_width = width - margin.left - margin.right
    let bubble_height = height - margin.top - margin.bottom

    //Variables using the products data
    let products_data
    let country_counts

    //mapping from country name to country code supported by the api
    let country_code_mapping


    //Variables using the percent data
    let percents_data
    let percents_items_normalized, percents_items, percents_removed_percent

    //maps each continent to its abbreviation
    const continent_mapping_a = {
        "North America": "NA",
        "South America": "SA",
        "Asia": "AS",
        "Oceania": "OC",
        "Europe": "EU",
        "Africa": "AF"
    }
    //maps each continent abbreviation to its full name
    const continent_mapping_b = {
        "NA": "North America",
        "SA": "South America",
        "AS": "Asia",
        "OC": "Oceania",
        "EU": "Europe",
        "AF": "Africa"
    }

    let countries_sorted

    //Variable that controls the dropdown
    let current_continent = "All"
    let dropdown_options = ["All", "North America", "South America", "Asia", "Europe", "Africa", "Oceania"]


    //Misc Variables
    let country_to_continent = new Map()
    let continent_to_country = new Map()
    let timer, floattimer, timer_ctr = 0
    var finishedLoading = false

    const make_loading_screen = (elapsed) => {
        var loading_background = d3.select(".loading")
        var numcircles = 6
        var circles_colors = d3.scaleOrdinal().domain(d3.range(numcircles)).range(d3.schemeTableau10)
        var placement = d3.scaleLinear().domain([0, 5]).range([window.innerWidth / 4, window.innerWidth * 3 / 4.0])
        var radius = 10
        var timeinterval = 5000

        if (timer_ctr == 0) { //prior to loading, set up the loading dots
            console.log(elapsed)
            let divs = document.getElementsByTagName("div")

            //disable scrolling
            let body = document.getElementsByTagName("body")[0]
            body.style.cssText = "margin: 0; height: 100%; overflow: hidden"

            loading_background
                .style("background-color", "white")
                .style("visibility", "visible")

            let loading = loading_background.append("svg")
                .attr("class", "loading_svg")
                .attr("height", window.innerHeight)
                .attr("width", window.innerWidth)

            loading.append("text")
                .attr("class", "loading-text")
                .attr("transform", "translate(" + (window.innerWidth / 2) + " ," +
                    (window.innerHeight / 2 - 150) + ")")
                .style("text-anchor", "middle")
                .style("font-size", 24)
                .attr("dy", "20")
                .text("You wanna see some cool stuff? (replace with first paragraph of intro)")

            //set up loading dots (empty initially)
            for (let i = 0; i < numcircles; i++) {
                loading.append("circle")
                    .attr("cx", placement(i))
                    .attr("cy", window.innerHeight * 3 / 4)
                    .attr("r", radius)
                    .style("fill", "white")
                    .attr("stroke", "black")
            }

        } else if (elapsed > timeinterval) { //finished loading
            console.log("Timer stopped")
            document.getElementsByTagName("body")[0].style = '' //re-enable scrolling
            let divs = document.getElementsByTagName("div") //rerender all elements
            for (let i = 0; i < divs.length; i++) {
                divs[i].style = 'visibility : visible'
            }
            loading_background  //hide loading screen
                .style("visibility", "hidden")
            finishedLoading = true
            set_up_axis_and_labels()
            timer.stop()
        } else { //during loading

            var loading = loading_background.select("svg")
            if (elapsed >= timeinterval / 2) { //display second paragraph
                loading.selectAll("text").remove()
                loading.append("text")
                    .attr("class", "loading-text")
                    .attr("transform", "translate(" + (window.innerWidth / 2) + " ," +
                        (window.innerHeight / 2 - 150) + ")")
                    .style("text-anchor", "middle")
                    .style("font-size", 24)
                    .attr("dy", "20")
                    .text("Now what")
            }
            loading.selectAll("circle")
                .transition()
                .ease(d3.easeLinear)
                .style("fill", function (d, i) { //filling magic
                    if (((timeinterval / 5) / (numcircles + 1)) * i < elapsed % (timeinterval / 5)) {
                        return circles_colors(i)
                    } else {
                        return "white"
                    }
                })

        }
        timer_ctr += 1
    }

    const get_countrget_country_flag_big_icon_url_icon_url = (country_name) => {
        //console.log(country_name)
        let country_code = country_code_mapping[country_name]
        //console.log(country_code)
        let url = `https://flagcdn.com/h240/${country_code}.png`
        return url
    }

    const get_country_flag_small_icon_url = (country_name) => {
        let country_code = country_code_mapping[country_name]
        let url = `https://flagcdn.com/16x12/${country_code}.png`
        return url
    }

    //Check to see if two circles intersect each other
    //c1 - [x1, y1] circle 1 center
    //r1 - radius of circle 1
    //c2 - [x2, y2] circle 2 center
    //r2 - radius of circle 2
    const check_intersection = (c1, r1, c2, r2) => {
        d = Math.sqrt((c1[0] - c2[0]) * (c1[0] - c2[0]) + (c1[1] - c2[1]) * (c1[1] - c2[1]))
        if ((d <= r1 - r2) || (d <= r2 - r1) || (d < r1 + r2) || (d == r1 + r2))
            return true
        return false
    }

    //A circle takes up a x-span of space. i.e. [c-r, c+r]
    //You can check to see if any circles cross that plane; they have to in order to intersect the circle
    const check_breaks_plane = (c1, r1, c2, r2) => {
        let left = c1[0] - r1
        let right = c1[0] + r1
        if (((c2[0] + r2 > left) && c2[0] <= c1[0]) || ((c2[0] - r2 < right) && c2[0] >= c1[0])) {
            return true
        }
        return false
    }

    //Get all possible y-values of the circle to be placed
    // const get_possible = (c1, r1, c2, r2) => {
    //     let min = margin.top, max = bubble_height, step = 0.1, diff = 0.01
    //     let works = []
    //     let current = min
    //     do {
    //         if (!check_intersection([c1[0], current], r1, c2, r2)) {
    //             works.push(current)
    //         }
    //         current += step
    //     } while (current <= max)
    //
    //     //Only need the point closest to the axis
    //     //Find the largest y-value thats above the center that's valid
    //     let left = works.filter(d => d < c2[1])
    //     if (left.length == 0) {
    //         left = 0
    //     } else {
    //         left = d3.max(left)
    //     }
    //
    //     //Find the smallest y-value below the center that's valid
    //     let right = works.filter(d => d > c2[1])
    //     if (right.length == 0) {
    //         left = height
    //     } else {
    //         right = d3.min(right)
    //     }
    //
    //     return [left, right]
    // }

    const get_possible = (c1, r1, c2, r2) => {
        var xlen = Math.abs(c1[0]-c2[0])
        var hypot = Math.abs(r1+r2)
        if(xlen == 0)
        {
            return [c2[1]-r2-r1, c2[1]+r2+r1]
        }
        var delta = Math.sqrt(Math.pow(hypot,2)-Math.pow(xlen, 2))
        return [c2[1]-delta, c2[1]+delta]
    }

    //Let code merge ranges (because the ends are the "best" placements for the circles)
    const merge_ranges = (intervals, r) => {
        var result = []
        var previous = intervals[0]

        for (let i = 1; i < intervals.length; i += 1) {
            if (previous[1] >= intervals[i][0]) {
                previous = [previous[0], Math.max(previous[1], intervals[i][1])]
            } else {
                result.push(previous)
                previous = intervals[i]
            }
        }
        result.push(previous)

        intervals = result
        // console.log(intervals)
        var previous = intervals[0]

        //Find the value that closest to the axis
        var best = previous[0]
        for (let i = 1; i < intervals.length; i += 1) {
            if (intervals[i][0] - previous[1] >= r * 2) { //Make sure that the space is large enough for the diameter
                if (Math.abs(((bubble_height + margin.top) / 2.0) - previous[1]) < Math.abs(((bubble_height + margin.top) / 2.0) - best)) {
                    best = previous[1]
                }
                if (Math.abs(((bubble_height + margin.top) / 2.0) - intervals[i][0]) < Math.abs(((bubble_height + margin.top) / 2.0) - best)) {
                    best = intervals[i][0]
                }
            }
            previous = intervals[i]
        }
        if (Math.abs(((bubble_height + margin.top) / 2.0) - previous[1]) < Math.abs(((bubble_height + margin.top) / 2.0) - best)) {
            best = previous[1]
        }

        return best
    }


    //Find the best y-values for the points
    const open_y = (placed_circles, result_y, this_point, xScale, sizeScale) => {
        if (placed_circles.length == 0) {
            return new Promise(resolve => setTimeout(() => resolve(result_y), 1))
        }
        const get_halo_stroke_width = (radius) => {
            if (radius >= 5 && radius <= 10) {
                return 2
            } else if (radius > 10 && radius <= 20) {
                return 3
            } else if (radius > 20 && radius <= 40) {
                return 4
            } else if (radius > 40) {
                return 5
            } else {
                return 1
            }
        }

        //Find the circles that broke the plane
        temp_placed_circles = []
        this_center = [xScale(percents_removed_percent.get(this_point[0])), result_y]
        this_radius = sizeScale(this_point[1]) //+ get_halo_stroke_width(sizeScale(this_point[1]))
        placed_circles.forEach(d => {
            other_center = [xScale(percents_removed_percent.get(d[0])), d[2]]
            other_radius = sizeScale(d[1]) + get_halo_stroke_width(sizeScale(d[1]))
            if (check_breaks_plane(this_center, this_radius, other_center, other_radius)) {
                temp_placed_circles.push(d)
            }
        })
        if (temp_placed_circles.length == 0) {
            return new Promise(resolve => setTimeout(() => resolve(result_y), 1))
        }

        //For each circle that broke the plane, see the two ends of valid values
        var valid_heights = []
        temp_placed_circles.forEach(d => {
            other_center = [xScale(percents_removed_percent.get(d[0])), d[2]]
            other_radius = sizeScale(d[1]) + get_halo_stroke_width(sizeScale(d[1]))
            valid_heights.push(get_possible(this_center, this_radius, other_center, other_radius))
        })

        //Combine the ranges and pick a single best point
        best_place = merge_ranges(valid_heights.sort((a, b) => d3.ascending(a[0], b[0])), this_radius)
        return new Promise(resolve => setTimeout(() => resolve(best_place), 1))
    }

    const xScale = d3.scaleLinear().domain([0, 1]).range([margin.left, bubble_width])

    const continentColorScale = d3.scaleOrdinal().domain(continent_to_country.keys()).range(d3.schemeTableau10)

    const preprocess_countries = async () => {
        const sizeScale = d3.scaleLog().domain([d3.least(country_counts, ([, v]) => v)[1],
            (d3.least(country_counts, ([, v]) => v)[1] + d3.greatest(country_counts, ([, v]) => v)[1]) / 2.0,
            d3.greatest(country_counts, ([, v]) => v)[1]]).range([(width / 1920) * 5, (width / 1920) * 35, (width / 1920) * 70])
        var countries_preprocessed = Array.from(country_counts).sort((a, b) => d3.descending(a[1], b[1]))//.filter(function (d) { return d[1] > 500});

        //append initial y-value and opacity is full
        countries_preprocessed.forEach((d, i) => {
            countries_preprocessed[i] = countries_preprocessed[i].concat((bubble_height + margin.top) / 2.0)
            countries_preprocessed[i] = countries_preprocessed[i].concat(true)
        })
        for (let i in countries_preprocessed) {
            console.log(i)
            countries_preprocessed[i][2] = await open_y(countries_preprocessed.filter((e, j) => j < i),
                countries_preprocessed[i][2], countries_preprocessed[i], xScale, sizeScale)
        }
        countries_sorted = countries_preprocessed
        console.log("finished processing")
    }

    const createIcons = async () => {

        const getId = d => d.toLowerCase().replace(/ /g, "-")


        //create country flags
        //console.log(countries_sorted)
        defs.selectAll(".country-pattern")
            .data(countries_sorted)
            .join(
                enter => enter.append("pattern")
                    .attr("class", "country-pattern")
                    .attr("id", d => getId(d[0]))
                    .attr("height", "100%")
                    .attr("width", "100%")
                    .attr("patternContentUnits", "objectBoundingBox")
                    .append("image")
                    .attr("height", 1)
                    .attr("width", 1)
                    .attr("preserveAspectRatio", "xMidYMin slice")
                    .attr("xlink:href", d => get_countrget_country_flag_big_icon_url_icon_url(d[0])
                    ),
                exit => exit
                    .remove()
            )
    }

    const drawBubble = async () => {
        const getId = d => d.toLowerCase().replace(/ /g, "-")

        const sizeScale = d3.scaleLog().domain([d3.least(country_counts, ([, v]) => v)[1],
            (d3.least(country_counts, ([, v]) => v)[1] + d3.greatest(country_counts, ([, v]) => v)[1]) / 2.0,
            d3.greatest(country_counts, ([, v]) => v)[1]]).range([(width / 1920) * 5, (width / 1920) * 35, (width / 1920) * 70])

        const get_halo_stroke_width = (radius) => {
            if (radius >= 5 && radius <= 10) {
                return 2
            } else if (radius > 10 && radius <= 20) {
                return 3
            } else if (radius > 20 && radius <= 40) {
                return 4
            } else if (radius > 40) {
                return 5
            } else {
                return 1
            }
        }

        const subset_countries = () => {
            //Sort most requests to least
            var subset_countries = countries_sorted
            // console.log("countries sorted: ", countries_preprocessed)
            //filter based on dropdown
            switch (continent_mapping_a[current_continent]) {
                case "NA":
                    subset_countries = countries_sorted.filter(d => continent_to_country.get("NA").has(d[0]))
                    break
                case "SA":
                    subset_countries = countries_sorted.filter(d => continent_to_country.get("SA").has(d[0]))
                    break
                case "AS":
                    subset_countries = countries_sorted.filter(d => continent_to_country.get("AS").has(d[0]))
                    break
                case "OC":
                    subset_countries = countries_sorted.filter(d => continent_to_country.get("OC").has(d[0]))
                    break
                case "AF":
                    subset_countries = countries_sorted.filter(d => continent_to_country.get("AF").has(d[0]))
                    break
                case "EU":
                    subset_countries = countries_sorted.filter(d => continent_to_country.get("EU").has(d[0]))
                    break

            }
            return subset_countries
        }

        let country_selection = subset_countries()
        countries_sorted.forEach(function (d, i) {
            if (country_selection.includes(d)) {
                countries_sorted[i][3] = true
            } else {
                countries_sorted[i][3] = false
            }

        })


        //draw circles
        var node = svg_bubble.selectAll("circle.country")
            .data(countries_sorted)
            .join(
                enter => enter.append("circle")
                    .attr("class", "country")
                    .attr("country", d => d[0])
                    .attr("cx", d => xScale(percents_removed_percent.get(d[0])))
                    .attr("cy", d => d[2])
                    .transition().duration(1000)
                    .attr("r", d => sizeScale(d[1]))
                    // .attr("fill", d => countryColorScale(d[0]))
                    .attr("fill", d => `url(#${getId(d[0])})`)
                    .attr("stroke", d => continentColorScale(country_to_continent.get(d[0])))
                    .attr("stroke-width", d => get_halo_stroke_width(sizeScale(d[1])))
                ,
                update => update
                    .style("opacity", function (d) {
                        if (d[3]) {
                            return 1
                        }
                        return 0.1
                    })
                ,

                exit => exit.remove()
            )
            .on("mouseover", (event, d) => {
                if (d[3]) {
                    tooltip
                        .style("opacity", 1)
                        .style("display","block")
                }
            })
            .on("mousemove", (event, d) => {
                let html_content = `<u>${d[0]}</u>   <img src="${get_country_flag_small_icon_url(d[0])}"
                        class="tool-tip-flag-icon"/>
                        <br>Removal Requests: ${d[1]}<br>%Removed: ${Math.round(percents_removed_percent.get(d[0]) * 10000) / 100}`

                tooltip
                    .html(html_content)
                    .style("left", (event.pageX + 20) + "px")
                    .style("top", (event.pageY - 30) + "px")
                    .style("border", `2px solid ${continentColorScale(country_to_continent.get(d[0]))}`)
            })

            .on("mouseleave", (event, d) => {
                tooltip
                    .style("opacity", 0)
            })
            .call(d3.drag() // call specific function when circle is dragged
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended))

        var simulation = d3.forceSimulation()
            .force("y", d3.forceY().strength(1).y(function (d) {
                return d[2]
            }))
            .force("x", d3.forceX().strength(1).x(function (d) {
                return xScale(percents_removed_percent.get(d[0]))
            }))
            //.force("center", d3.forceCenter().x(function(d){return console.log(xScale(percents_removed_percent.get(d[0]))); xScale(percents_removed_percent.get(d[0]))}).y((bubble_height + margin.top) / 2))
            //.force("charge", d3.forceManyBody().strength(-1))
            .force("collide", d3.forceCollide().strength(0.25).radius(function (d) {
                if (d[3]) {
                    return sizeScale(d[1])
                } else {
                    return -1
                    console.log(d)
                }
            }).iterations(1))


        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(.03).restart()
            d.fx = d.x
            d.fy = d.y
        }

        function dragged(event, d) {
            d.fx = event.x
            d.fy = event.y
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(.03)
            d.fx = null
            d.fy = null
        }

        simulation
            .nodes(countries_sorted)
            .on("tick", function (d) {
                node
                    .attr("cx", function (d) {
                        return d.x
                    })
                    .attr("cy", function (d) {
                        return d.y
                    })
            })


    }


    //parse the csv files and perform calculations
    const prep_data = () => {

        country_counts = d3.rollup(products_data, v => d3.sum(v, d => +d.total), d => d.country)

        //go through every row and multiply the number of items requested to be removed by the percent of the 2 removed categories
        //can be changed
        percents_items_normalized = d3.rollup(percents_data, v => d3.sum(v, d => (+d.items) * ((+d.removed_legal + (+d.removed_policy)) / 100.0)), d => d.country)
        percents_items = d3.rollup(percents_data, v => d3.sum(v, d => +d.items), d => d.country)
        percents_removed_percent = new d3.InternMap()
        Array.from(percents_items.keys()).forEach(e => {
            percents_removed_percent.set(e, percents_items_normalized.get(e) / percents_items.get(e))
        })

        //remove countries from country counts that aren't in the percentages table
        Array.from(country_counts.keys()).forEach(e => {
            if (!percents_removed_percent.has(e)) {
                country_counts.delete(e)
            }
        })

        //country_continents = d3.group(percents_data, d => d.continent, d=> d.country)

        //create mappings: continents ->countries, country->continent
        percents_data.forEach(e => {
            let continent = e.continent
            let country = e.country

            //continents -> countries
            if (!continent_to_country.has(continent)) {
                continent_to_country.set(continent, new Set([country]))
            } else {
                continent_to_country.get(continent).add(country)
            }

            //countries -> continents
            country_to_continent.set(country, continent)

        })

        // console.log(continent_to_country)

    }

    const set_up_axis_and_labels = () => {
        if (finishedLoading) { //move "loading dots" to legend location
            svg_bubble.selectAll(".mydots")
                .transition()
                .ease(d3.easeLinear)
                .duration(750)
                .attr("cx", width - margin.right - 150)
                .attr("cy", function (d, i) {
                    return 100 + i * 25
                }) // 100 is where the first dot appears. 25 is the distance between dots
                .attr("r", 7)
            return
        } else {
            //add axis and text

            //x-axis
            let xAxis = svg_bubble.append("g")
                .attr("class", "x-axis")
                .attr("transform", "translate(" + 0 + "," + (bubble_height + margin.top) / 2.0 + ")")
                .call(d3.axisBottom(d3.scaleLinear().domain([0, 1]).range([margin.left, bubble_width + 50])).tickValues([]).tickSize(0))

            xAxis
                .attr("stroke-width", "5")

            //x-axis label
            svg_bubble.append("text")
                .attr("class", "x-axis-label")
                .attr("transform", "translate(" + (width - margin.right - 50) + " ," +
                    (height / 2 + 75) + ")")
                .style("text-anchor", "middle")
                .attr("dy", "12")
                .text("% of Acceptance")


            //draw lines that mark the quadrants
            let quadrant_lines = svg_bubble.selectAll("lines.quadrant-line")
                .data(quadrants)
                .enter()
                .append("line")
            quadrant_lines.attr("class", "quadrant-line")
                .attr("x1", d => xScale(d))
                .attr("y1", margin.top + 20)
                .attr("x2", d => xScale(d))
                .attr("y2", height - 100)
                .attr("stroke", "#f8e1ed")
                .attr("stroke-width", 5)

            //quadrant labels above line
            let quadrant_lines_label = svg_bubble.selectAll("text.quadrant-line-label")
                .data(quadrants)
                .enter()
                .append("text")

            quadrant_lines_label
                .attr("class", "quadrant-line-label")
                .attr("transform", d => "translate(" + (xScale(d)) + " ," +
                    (margin.top - 10) + ")")
                .style("text-anchor", "middle")
                .attr("dy", "12")
                .text(d => `${d * 100}%`)

            //add arrow at the end of x axis

            defs.append("marker")
                .attr("id", "arrowhead")
                .attr("refX", 2)
                .attr("refY", 7)
                .attr("markerWidth", 8)
                .attr("markerHeight", 13)
                .attr("orient", "right")
                .append("path")
                .attr("d", "M2,2 L2,13 L8,7 L2,2")

            xAxis.select("path").attr("marker-end", "url(#arrowhead)")

            //add legend

            var placement = d3.scaleLinear().domain([0, 5]).range([window.innerWidth / 4, (window.innerWidth * 3) / 4])
            var radius = 50
            var element = document.getElementsByClassName("dropdown-wrapper")[0]
            var dropdown_bounds = element.getBoundingClientRect()
            var circles_colors = d3.scaleOrdinal().domain(d3.range(6)).range(d3.schemeTableau10)

            for (i = 0; i < 6; i++) {
                svg_bubble
                    .append("circle")
                    .attr("class", "mydots")
                    .attr("cx", placement(i) - dropdown_bounds.left)
                    .attr("cy", function () {
                        return (window.innerHeight / 2) - dropdown_bounds.bottom
                    })
                    .attr("r", radius)
                    .style("fill", circles_colors(i))
                    .attr("stroke", "black")
            }


            //legend text
            svg_bubble.selectAll("text.legend-label")
                .data(Array.from(continent_to_country.keys()).map(d => continent_mapping_b[d]))
                .enter()
                .append("text")
                .attr("class", "legend-label")
                .attr("x", width - margin.right - 140)
                .attr("y", (d, i) => 100 + i * 25)
                .style("fill", d => continentColorScale(continent_mapping_a[d]))
                .text(d => d)
                .attr("text-anchor", "left")
                .style("alignment-baseline", "middle")

        }

    }

    const set_up_dropdown = () => {
        d3.selectAll(".dropdown").selectAll('myOptions').data(dropdown_options).enter()
            .append('option')
            .text(d => d) // text showed in the menu
            .attr("value", d => d)

        d3.select(".dropdown")
            .on("change", (e, d) => {
                current_continent = e.currentTarget.value
                // console.log(current_continent);

                //draw bubble again
                drawBubble()
            })
    }


    const ready = async () => {
        products_data = await d3.csv("removal-requests-products.csv")
        percents_data = await d3.csv("removal-requests-percents.csv")
        country_code_mapping = await d3.json("country-code-mapping.json")

        timer = d3.timer(make_loading_screen)

        //load dropdown
        set_up_dropdown()

        prep_data()

        set_up_axis_and_labels()
        await preprocess_countries()
        await createIcons()
        drawBubble()
    }


    ready()
</script>

</body>


